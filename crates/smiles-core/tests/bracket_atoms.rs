//! Tests des atomes entre crochets
//!
//! Ces tests vérifient le parsing des atomes entre crochets avec:
//! - Hydrogènes explicites (`[CH4]`, `[CH3]`, etc.)
//! - Charges (`[NH4+]`, `[O-]`, `[Fe+2]`, etc.)
//! - Isotopes (`[13C]`, `[2H]`, etc.)
//! - Classes/atom mapping (`[C:1]`, `[N:2]`, etc.)
//! - Toutes les combinaisons possibles de ces attributs

use smiles_core::{parse, AtomSymbol, OrganicAtom};

// ============================================================================
// Hydrogènes explicites
// ============================================================================

#[test]
#[ignore] // Pas encore implémenté
fn parse_bracket_atom_no_hydrogen() {
    // [C] = carbone sans hydrogène explicite (radical)
    let molecule = parse("[C]").expect("Failed to parse [C]");

    assert_eq!(molecule.nodes().len(), 1);

    let node = &molecule.nodes()[0];
    assert_eq!(*node.atom().element(), AtomSymbol::Organic(OrganicAtom::C));
    assert_eq!(node.hydrogens(), 0);
    assert_eq!(node.atom().charge(), 0);
    assert_eq!(node.atom().isotope(), None);
    assert_eq!(node.class(), None);
}

#[test]
#[ignore] // Pas encore implémenté
fn parse_bracket_atom_with_hydrogen_count() {
    // [CH4] = méthane avec hydrogènes explicites
    let molecule = parse("[CH4]").expect("Failed to parse [CH4]");

    assert_eq!(molecule.nodes().len(), 1);

    let node = &molecule.nodes()[0];
    assert_eq!(*node.atom().element(), AtomSymbol::Organic(OrganicAtom::C));
    assert_eq!(node.hydrogens(), 4);
}

#[test]
#[ignore] // Pas encore implémenté
fn parse_bracket_atom_hydrogen_implicit_one() {
    // [CH] = carbone avec 1 hydrogène (H sans nombre = 1)
    let molecule = parse("[CH]").expect("Failed to parse [CH]");

    assert_eq!(molecule.nodes().len(), 1);
    assert_eq!(molecule.nodes()[0].hydrogens(), 1);
}

#[test]
#[ignore] // Pas encore implémenté
fn parse_bracket_hydrogen_variations() {
    // Tester différentes valeurs d'hydrogènes
    let test_cases = [
        ("[CH]", 1),
        ("[CH2]", 2),
        ("[CH3]", 3),
        ("[NH2]", 2),
        ("[OH]", 1),
        ("[SH]", 1),
    ];

    for (smiles, expected_h) in test_cases {
        let molecule = parse(smiles).expect(&format!("Failed to parse {}", smiles));
        assert_eq!(
            molecule.nodes()[0].hydrogens(),
            expected_h,
            "Wrong hydrogen count for {}",
            smiles
        );
    }
}

// ============================================================================
// Charges
// ============================================================================

#[test]
#[ignore] // Pas encore implémenté
fn parse_bracket_atom_positive_charge() {
    // [NH4+] = ion ammonium
    let molecule = parse("[NH4+]").expect("Failed to parse [NH4+]");

    assert_eq!(molecule.nodes().len(), 1);

    let node = &molecule.nodes()[0];
    assert_eq!(*node.atom().element(), AtomSymbol::Organic(OrganicAtom::N));
    assert_eq!(node.atom().charge(), 1);
    assert_eq!(node.hydrogens(), 4);
}

#[test]
#[ignore] // Pas encore implémenté
fn parse_bracket_atom_negative_charge() {
    // [O-] = ion oxyde
    let molecule = parse("[O-]").expect("Failed to parse [O-]");

    assert_eq!(molecule.nodes().len(), 1);

    let node = &molecule.nodes()[0];
    assert_eq!(*node.atom().element(), AtomSymbol::Organic(OrganicAtom::O));
    assert_eq!(node.atom().charge(), -1);
}

#[test]
#[ignore] // Pas encore implémenté
fn parse_bracket_atom_multiple_charge_plus() {
    // [Fe++] ou [Fe+2] = ion fer(II)
    let molecule1 = parse("[Fe++]").expect("Failed to parse [Fe++]");
    let molecule2 = parse("[Fe+2]").expect("Failed to parse [Fe+2]");

    assert_eq!(molecule1.nodes()[0].atom().charge(), 2);
    assert_eq!(molecule2.nodes()[0].atom().charge(), 2);
}

#[test]
#[ignore] // Pas encore implémenté
fn parse_bracket_atom_multiple_charge_minus() {
    // [O--] ou [O-2] = ion oxyde doublement chargé
    let molecule1 = parse("[O--]").expect("Failed to parse [O--]");
    let molecule2 = parse("[O-2]").expect("Failed to parse [O-2]");

    assert_eq!(molecule1.nodes()[0].atom().charge(), -2);
    assert_eq!(molecule2.nodes()[0].atom().charge(), -2);
}

#[test]
#[ignore] // Pas encore implémenté
fn parse_bracket_atom_high_charge() {
    // Charges élevées (jusqu'à +/-15 selon la spécification)
    let molecule_pos = parse("[Fe+3]").expect("Failed to parse [Fe+3]");
    let molecule_neg = parse("[P-3]").expect("Failed to parse [P-3]");

    assert_eq!(molecule_pos.nodes()[0].atom().charge(), 3);
    assert_eq!(molecule_neg.nodes()[0].atom().charge(), -3);
}

// ============================================================================
// Isotopes
// ============================================================================

#[test]
#[ignore] // Pas encore implémenté
fn parse_bracket_atom_isotope() {
    // [13C] = carbone-13
    let molecule = parse("[13C]").expect("Failed to parse [13C]");

    assert_eq!(molecule.nodes().len(), 1);

    let node = &molecule.nodes()[0];
    assert_eq!(*node.atom().element(), AtomSymbol::Organic(OrganicAtom::C));
    assert_eq!(node.atom().isotope(), Some(13));
}

#[test]
#[ignore] // Pas encore implémenté
fn parse_bracket_atom_deuterium() {
    // [2H] = deutérium
    let molecule = parse("[2H]").expect("Failed to parse [2H]");

    assert_eq!(molecule.nodes().len(), 1);
    assert_eq!(*molecule.nodes()[0].atom().element(), AtomSymbol::H);
    assert_eq!(molecule.nodes()[0].atom().isotope(), Some(2));
}

#[test]
#[ignore] // Pas encore implémenté
fn parse_bracket_atom_tritium() {
    // [3H] = tritium
    let molecule = parse("[3H]").expect("Failed to parse [3H]");

    assert_eq!(molecule.nodes()[0].atom().isotope(), Some(3));
}

#[test]
#[ignore] // Pas encore implémenté
fn parse_bracket_atom_oxygen_18() {
    // [18O] = oxygène-18
    let molecule = parse("[18O]").expect("Failed to parse [18O]");

    assert_eq!(
        *molecule.nodes()[0].atom().element(),
        AtomSymbol::Organic(OrganicAtom::O)
    );
    assert_eq!(molecule.nodes()[0].atom().isotope(), Some(18));
}

// ============================================================================
// Classes (atom mapping)
// ============================================================================

#[test]
#[ignore] // Pas encore implémenté
fn parse_bracket_atom_class() {
    // [C:1] = carbone avec classe 1
    let molecule = parse("[C:1]").expect("Failed to parse [C:1]");

    assert_eq!(molecule.nodes().len(), 1);

    let node = &molecule.nodes()[0];
    assert_eq!(*node.atom().element(), AtomSymbol::Organic(OrganicAtom::C));
    assert_eq!(node.class(), Some(1));
}

#[test]
#[ignore] // Pas encore implémenté
fn parse_bracket_atom_class_variations() {
    // Tester différentes valeurs de classes
    let test_cases = [("[C:0]", 0), ("[C:1]", 1), ("[C:42]", 42), ("[C:999]", 999)];

    for (smiles, expected_class) in test_cases {
        let molecule = parse(smiles).expect(&format!("Failed to parse {}", smiles));
        assert_eq!(
            molecule.nodes()[0].class(),
            Some(expected_class),
            "Wrong class for {}",
            smiles
        );
    }
}

// ============================================================================
// Combinaisons de 2 attributs
// ============================================================================

#[test]
#[ignore] // Pas encore implémenté
fn parse_bracket_atom_hydrogen_and_charge() {
    // [NH4+] = ammonium : hydrogènes + charge
    let molecule = parse("[NH4+]").expect("Failed to parse [NH4+]");

    let node = &molecule.nodes()[0];
    assert_eq!(node.hydrogens(), 4);
    assert_eq!(node.atom().charge(), 1);
}

#[test]
#[ignore] // Pas encore implémenté
fn parse_bracket_atom_isotope_and_hydrogen() {
    // [13CH4] = méthane marqué au carbone-13
    let molecule = parse("[13CH4]").expect("Failed to parse [13CH4]");

    let node = &molecule.nodes()[0];
    assert_eq!(node.atom().isotope(), Some(13));
    assert_eq!(node.hydrogens(), 4);
}

#[test]
#[ignore] // Pas encore implémenté
fn parse_bracket_atom_isotope_and_charge() {
    // [13C-] = carbone-13 anionique
    let molecule = parse("[13C-]").expect("Failed to parse [13C-]");

    let node = &molecule.nodes()[0];
    assert_eq!(node.atom().isotope(), Some(13));
    assert_eq!(node.atom().charge(), -1);
}

#[test]
#[ignore] // Pas encore implémenté
fn parse_bracket_atom_hydrogen_and_class() {
    // [CH3:1] = méthyle avec classe
    let molecule = parse("[CH3:1]").expect("Failed to parse [CH3:1]");

    let node = &molecule.nodes()[0];
    assert_eq!(node.hydrogens(), 3);
    assert_eq!(node.class(), Some(1));
}

#[test]
#[ignore] // Pas encore implémenté
fn parse_bracket_atom_charge_and_class() {
    // [O-:2] = oxyde avec classe
    let molecule = parse("[O-:2]").expect("Failed to parse [O-:2]");

    let node = &molecule.nodes()[0];
    assert_eq!(node.atom().charge(), -1);
    assert_eq!(node.class(), Some(2));
}

#[test]
#[ignore] // Pas encore implémenté
fn parse_bracket_atom_isotope_and_class() {
    // [13C:1] = carbone-13 avec classe
    let molecule = parse("[13C:1]").expect("Failed to parse [13C:1]");

    let node = &molecule.nodes()[0];
    assert_eq!(node.atom().isotope(), Some(13));
    assert_eq!(node.class(), Some(1));
}

// ============================================================================
// Combinaisons de 3 attributs
// ============================================================================

#[test]
#[ignore] // Pas encore implémenté
fn parse_bracket_atom_isotope_hydrogen_charge() {
    // [13CH3+] = méthyle cation marqué
    let molecule = parse("[13CH3+]").expect("Failed to parse [13CH3+]");

    let node = &molecule.nodes()[0];
    assert_eq!(node.atom().isotope(), Some(13));
    assert_eq!(node.hydrogens(), 3);
    assert_eq!(node.atom().charge(), 1);
}

#[test]
#[ignore] // Pas encore implémenté
fn parse_bracket_atom_isotope_hydrogen_class() {
    // [13CH4:1] = méthane marqué avec classe
    let molecule = parse("[13CH4:1]").expect("Failed to parse [13CH4:1]");

    let node = &molecule.nodes()[0];
    assert_eq!(node.atom().isotope(), Some(13));
    assert_eq!(node.hydrogens(), 4);
    assert_eq!(node.class(), Some(1));
}

#[test]
#[ignore] // Pas encore implémenté
fn parse_bracket_atom_isotope_charge_class() {
    // [13C+:1] = carbone-13 cation avec classe
    let molecule = parse("[13C+:1]").expect("Failed to parse [13C+:1]");

    let node = &molecule.nodes()[0];
    assert_eq!(node.atom().isotope(), Some(13));
    assert_eq!(node.atom().charge(), 1);
    assert_eq!(node.class(), Some(1));
}

#[test]
#[ignore] // Pas encore implémenté
fn parse_bracket_atom_hydrogen_charge_class() {
    // [NH4+:1] = ammonium avec classe
    let molecule = parse("[NH4+:1]").expect("Failed to parse [NH4+:1]");

    let node = &molecule.nodes()[0];
    assert_eq!(node.hydrogens(), 4);
    assert_eq!(node.atom().charge(), 1);
    assert_eq!(node.class(), Some(1));
}

// ============================================================================
// Combinaison de tous les attributs (4)
// ============================================================================

#[test]
#[ignore] // Pas encore implémenté
fn parse_bracket_atom_all_attributes() {
    // [13CH4+:1] = toutes les propriétés combinées
    let molecule = parse("[13CH4+:1]").expect("Failed to parse [13CH4+:1]");

    let node = &molecule.nodes()[0];
    assert_eq!(*node.atom().element(), AtomSymbol::Organic(OrganicAtom::C));
    assert_eq!(node.atom().isotope(), Some(13));
    assert_eq!(node.hydrogens(), 4);
    assert_eq!(node.atom().charge(), 1);
    assert_eq!(node.class(), Some(1));
}

#[test]
#[ignore] // Pas encore implémenté
fn parse_bracket_atom_all_attributes_negative() {
    // [18OH-:5] = hydroxyde marqué avec classe
    let molecule = parse("[18OH-:5]").expect("Failed to parse [18OH-:5]");

    let node = &molecule.nodes()[0];
    assert_eq!(*node.atom().element(), AtomSymbol::Organic(OrganicAtom::O));
    assert_eq!(node.atom().isotope(), Some(18));
    assert_eq!(node.hydrogens(), 1);
    assert_eq!(node.atom().charge(), -1);
    assert_eq!(node.class(), Some(5));
}

// ============================================================================
// Éléments non-organiques
// ============================================================================

#[test]
#[ignore] // Pas encore implémenté
fn parse_bracket_metal() {
    // [Fe] = fer
    let molecule = parse("[Fe]").expect("Failed to parse [Fe]");

    assert_eq!(molecule.nodes().len(), 1);
    assert_eq!(*molecule.nodes()[0].atom().element(), AtomSymbol::Fe);
}

#[test]
#[ignore] // Pas encore implémenté
fn parse_bracket_noble_gas() {
    // [He] = hélium
    let molecule = parse("[He]").expect("Failed to parse [He]");

    assert_eq!(*molecule.nodes()[0].atom().element(), AtomSymbol::He);
}

#[test]
#[ignore] // Pas encore implémenté
fn parse_bracket_lanthanide() {
    // [La] = lanthane
    let molecule = parse("[La]").expect("Failed to parse [La]");

    assert_eq!(*molecule.nodes()[0].atom().element(), AtomSymbol::La);
}
