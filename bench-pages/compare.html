<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SMILES Parser — Benchmark Comparisons</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
    <script src="./nav.js"></script>
    <style>
        :root {
            --bg: #ffffff;
            --bg-card: #f8fafc;
            --text: #1e293b;
            --text-muted: #64748b;
            --border: #e2e8f0;
            --blue: #3b82f6;
            --green: #10b981;
            --orange: #f59e0b;
            --purple: #8b5cf6;
            --red: #ef4444;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --bg-card: #1e293b;
                --text: #e2e8f0;
                --text-muted: #94a3b8;
                --border: #334155;
            }
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
            padding: 2rem;
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--border);
        }

        header h1 { font-size: 1.8rem; margin-bottom: 0.5rem; }
        header p { color: var(--text-muted); }
        header a { color: var(--blue); text-decoration: none; }
        header a:hover { text-decoration: underline; }

        .nav {
            display: flex;
            gap: 1rem;
            margin-top: 0.75rem;
            flex-wrap: wrap;
        }

        .nav a {
            color: var(--blue);
            text-decoration: none;
            padding: 0.25rem 0.75rem;
            border-radius: 0.375rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            font-size: 0.875rem;
        }
        .nav a:hover { border-color: var(--blue); }

        section {
            margin-bottom: 3rem;
        }

        section h2 {
            font-size: 1.4rem;
            margin-bottom: 0.5rem;
        }

        section .description {
            color: var(--text-muted);
            margin-bottom: 1rem;
            font-size: 0.95rem;
        }

        code {
            background: var(--bg-card);
            border: 1px solid var(--border);
            padding: 0.1rem 0.35rem;
            border-radius: 0.25rem;
            font-size: 0.85em;
        }

        .chart-container {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
            padding: 1.5rem;
            margin-bottom: 1rem;
        }

        .chart-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        @media (max-width: 768px) {
            .chart-row { grid-template-columns: 1fr; }
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
            overflow: hidden;
            font-size: 0.9rem;
        }

        th, td {
            padding: 0.75rem 1rem;
            text-align: right;
            border-bottom: 1px solid var(--border);
        }

        th {
            background: var(--bg);
            font-weight: 600;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
        }

        td:first-child, th:first-child { text-align: left; }
        tr:last-child td { border-bottom: none; }

        .speedup-positive { color: var(--green); font-weight: 600; }
        .speedup-negative { color: var(--red); font-weight: 600; }

        .badge {
            display: inline-block;
            padding: 0.125rem 0.5rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 600;
        }
        .badge-fast { background: #d1fae5; color: #065f46; }
        .badge-slow { background: #fee2e2; color: #991b1b; }

        @media (prefers-color-scheme: dark) {
            .badge-fast { background: #064e3b; color: #6ee7b7; }
            .badge-slow { background: #7f1d1d; color: #fca5a5; }
        }

        .last-updated {
            color: var(--text-muted);
            font-size: 0.8rem;
            margin-top: 2rem;
            text-align: center;
        }

        #loading {
            text-align: center;
            padding: 3rem;
            color: var(--text-muted);
        }

        #error {
            display: none;
            text-align: center;
            padding: 2rem;
            color: var(--red);
            background: var(--bg-card);
            border: 1px solid var(--red);
            border-radius: 0.75rem;
        }
    </style>
</head>
<body>

    <header>
        <h1>Benchmark Comparisons</h1>
        <p>Comparative analysis of parsing performance across configurations</p>
        <div class="nav">
            <a href="#section-seq-parallel">Seq vs Parallel</a>
            <a href="#section-scaling">Linear vs Branched</a>
            <a href="#section-reference">Reference Molecules</a>
        </div>
    </header>

    <div id="loading">Loading benchmark data&hellip;</div>
    <div id="error">
        <p><strong>Could not load benchmark data.</strong></p>
        <p>Make sure benchmarks have been run at least once on the master branch.</p>
    </div>

    <div id="content" style="display:none;">

        <!-- ========== Sequential vs Parallel ========== -->
        <section id="section-seq-parallel">
            <h2>Sequential vs Parallel Parsing</h2>
            <p class="description">
                Throughput comparison of sequential and parallel (Rayon) batch parsing
                across different dataset sizes. The crossover point shows where
                parallelism starts to pay off despite thread synchronization overhead.
            </p>
            <div class="chart-row">
                <div class="chart-container">
                    <canvas id="seqParallelTimeChart"></canvas>
                </div>
                <div class="chart-container">
                    <canvas id="seqParallelSpeedupChart"></canvas>
                </div>
            </div>
            <table id="seqParallelTable"></table>
        </section>

        <!-- ========== Scaling: Linear vs Branched ========== -->
        <section id="section-scaling">
            <h2>Scaling: Linear vs Branched Chains</h2>
            <p class="description">
                Parse time comparison between PEG (linear chain:
                <code>OCCOCCOCC&hellip;O</code>) and Teflon/PTFE (branched:
                <code>C(F)(F)C(F)(F)&hellip;</code>) at varying chain lengths.
                Helps detect O(n&sup2;) algorithmic regressions and measure
                branch parsing overhead.
            </p>
            <div class="chart-row">
                <div class="chart-container">
                    <canvas id="scalingTimeChart"></canvas>
                </div>
                <div class="chart-container">
                    <canvas id="scalingPerUnitChart"></canvas>
                </div>
            </div>
            <table id="scalingTable"></table>
        </section>

        <!-- ========== Reference Molecules ========== -->
        <section id="section-reference">
            <h2>Reference Molecules</h2>
            <p class="description">
                Parse time for 5 representative molecules of increasing complexity,
                useful for cross-language parser comparison (RDKit, OpenBabel, etc.).
            </p>
            <table id="referenceTable"></table>
        </section>

        <p class="last-updated" id="lastUpdated"></p>
    </div>

    <!-- data.js is generated by benchmark-action on gh-pages -->
    <script src="./data.js"></script>
    <script>
    (function () {
        'use strict';

        // ── Helpers ──────────────────────────────────────────────

        function formatNs(ns) {
            if (ns < 1000) return ns.toFixed(0) + ' ns';
            if (ns < 1e6)  return (ns / 1e3).toFixed(1) + ' \u00b5s';
            if (ns < 1e9)  return (ns / 1e6).toFixed(2) + ' ms';
            return (ns / 1e9).toFixed(2) + ' s';
        }

        function getLatestBenches() {
            if (!window.BENCHMARK_DATA) return null;
            var entries = Object.values(window.BENCHMARK_DATA.entries);
            if (!entries.length || !entries[0].length) return null;
            return entries[0][entries[0].length - 1];
        }

        function groupBenches(benches) {
            var groups = {
                seqParallel: { sequential: {}, parallel: {} },
                scaling:     { peg: {}, teflon: {} },
                reference:   {}
            };

            benches.forEach(function (bench) {
                var m;
                if ((m = bench.name.match(/^seq_vs_parallel\/sequential\/(\d+)$/))) {
                    groups.seqParallel.sequential[+m[1]] = bench.value;
                } else if ((m = bench.name.match(/^seq_vs_parallel\/parallel\/(\d+)$/))) {
                    groups.seqParallel.parallel[+m[1]] = bench.value;
                } else if ((m = bench.name.match(/^scaling\/peg\/(\d+)$/))) {
                    groups.scaling.peg[+m[1]] = bench.value;
                } else if ((m = bench.name.match(/^scaling\/teflon\/(\d+)$/))) {
                    groups.scaling.teflon[+m[1]] = bench.value;
                } else if ((m = bench.name.match(/^reference\/(.+)$/))) {
                    groups.reference[m[1]] = bench.value;
                }
            });

            return groups;
        }

        // ── Chart theme ──────────────────────────────────────────

        var COLORS = {
            blue:      '#3b82f6',  blueBg:   'rgba(59,130,246,0.7)',
            green:     '#10b981',  greenBg:  'rgba(16,185,129,0.7)',
            orange:    '#f59e0b',  orangeBg: 'rgba(245,158,11,0.7)',
            purple:    '#8b5cf6',  purpleBg: 'rgba(139,92,246,0.7)',
            slate:     '#64748b',  slateBg:  'rgba(100,116,139,0.7)'
        };

        function cssVar(name) {
            return getComputedStyle(document.documentElement)
                .getPropertyValue(name).trim();
        }
        function textColor()  { return cssVar('--text')       || '#1e293b'; }
        function mutedColor() { return cssVar('--text-muted') || '#64748b'; }

        // ── Generic bar chart factory ────────────────────────────

        function barChart(canvasId, cfg) {
            var tc = textColor(), mc = mutedColor();

            // Build tick configs — only set callback when a real function is
            // needed.  Setting `callback: undefined` on a Chart.js category
            // axis overrides the default label renderer and causes raw tick
            // indices (0, 1, 2 …) to be shown instead of the label strings.
            var xTicks = { color: mc };
            if (cfg.horizontal) {
                xTicks.callback = cfg.xTick || function (v) { return formatNs(v); };
            }

            var yTicks = { color: mc };
            if (!cfg.horizontal) {
                yTicks.callback = cfg.yTick || function (v) { return formatNs(v); };
            }

            var xScale = { ticks: xTicks, grid: { color: 'rgba(148,163,184,0.1)' } };
            if (cfg.xTitle) xScale.title = { display: true, text: cfg.xTitle, color: mc };
            if (cfg.horizontal && cfg.logScale) xScale.type = 'logarithmic';

            var yScale = { ticks: yTicks, grid: { color: 'rgba(148,163,184,0.1)' } };
            if (cfg.yTitle) yScale.title = { display: true, text: cfg.yTitle, color: mc };
            if (!cfg.horizontal && cfg.logScale) yScale.type = 'logarithmic';

            return new Chart(document.getElementById(canvasId), {
                type: 'bar',
                data: cfg.data,
                options: {
                    indexAxis: cfg.horizontal ? 'y' : 'x',
                    responsive: true,
                    plugins: {
                        title: {
                            display: !!cfg.title,
                            text: cfg.title || '',
                            color: tc,
                            font: { size: 14, weight: '600' }
                        },
                        legend: {
                            display: cfg.showLegend !== false,
                            labels: { color: tc }
                        },
                        tooltip: {
                            callbacks: {
                                label: cfg.tooltipLabel || function (ctx) {
                                    return ctx.dataset.label + ': ' + formatNs(ctx.raw);
                                }
                            }
                        }
                    },
                    scales: { x: xScale, y: yScale }
                }
            });
        }

        // ── Section builders ─────────────────────────────────────

        function buildSeqParallel(g) {
            var sizes = Object.keys(g.seqParallel.sequential)
                .map(Number).sort(function (a, b) { return a - b; });

            if (!sizes.length) {
                document.getElementById('section-seq-parallel').style.display = 'none';
                return;
            }

            var seqV = sizes.map(function (s) { return g.seqParallel.sequential[s]; });
            var parV = sizes.map(function (s) { return g.seqParallel.parallel[s]; });
            var speedups = sizes.map(function (_, i) { return seqV[i] / parV[i]; });

            // Time chart (log)
            barChart('seqParallelTimeChart', {
                title: 'Parse Time by Batch Size',
                xTitle: 'Batch Size',
                yTitle: 'Time (log scale)',
                logScale: true,
                data: {
                    labels: sizes.map(function (s) { return s.toLocaleString(); }),
                    datasets: [
                        { label: 'Sequential', data: seqV,
                          backgroundColor: COLORS.blueBg, borderColor: COLORS.blue, borderWidth: 1 },
                        { label: 'Parallel',   data: parV,
                          backgroundColor: COLORS.greenBg, borderColor: COLORS.green, borderWidth: 1 }
                    ]
                }
            });

            // Speedup chart
            barChart('seqParallelSpeedupChart', {
                title: 'Parallel Speedup Factor',
                xTitle: 'Batch Size',
                yTitle: 'Speedup (seq \u00f7 par)',
                yTick: function (v) { return v.toFixed(1) + 'x'; },
                tooltipLabel: function (ctx) { return ctx.raw.toFixed(2) + 'x'; },
                logScale: false,
                data: {
                    labels: sizes.map(function (s) { return s.toLocaleString(); }),
                    datasets: [{
                        label: 'Speedup',
                        data: speedups,
                        backgroundColor: speedups.map(function (s) {
                            return s >= 1 ? COLORS.greenBg : COLORS.orangeBg;
                        }),
                        borderColor: speedups.map(function (s) {
                            return s >= 1 ? COLORS.green : COLORS.orange;
                        }),
                        borderWidth: 1
                    }]
                }
            });

            // Table
            var html = '<thead><tr>' +
                '<th>Batch Size</th><th>Sequential</th><th>Parallel</th>' +
                '<th>Speedup</th><th>Winner</th></tr></thead><tbody>';

            sizes.forEach(function (size, i) {
                var sp = speedups[i];
                var cls  = sp >= 1 ? 'speedup-positive' : 'speedup-negative';
                var badge = sp >= 1
                    ? '<span class="badge badge-fast">Parallel</span>'
                    : '<span class="badge badge-slow">Sequential</span>';
                html += '<tr><td>' + size.toLocaleString() + '</td>' +
                    '<td>' + formatNs(seqV[i]) + '</td>' +
                    '<td>' + formatNs(parV[i]) + '</td>' +
                    '<td class="' + cls + '">' + sp.toFixed(2) + 'x</td>' +
                    '<td>' + badge + '</td></tr>';
            });

            html += '</tbody>';
            document.getElementById('seqParallelTable').innerHTML = html;
        }

        function buildScaling(g) {
            var pegSizes    = Object.keys(g.scaling.peg).map(Number).sort(function (a,b) { return a-b; });
            var teflonSizes = Object.keys(g.scaling.teflon).map(Number).sort(function (a,b) { return a-b; });

            if (!pegSizes.length && !teflonSizes.length) {
                document.getElementById('section-scaling').style.display = 'none';
                return;
            }

            var allSizes = pegSizes.concat(teflonSizes)
                .filter(function (v, i, a) { return a.indexOf(v) === i; })
                .sort(function (a, b) { return a - b; });

            // Time chart (log)
            barChart('scalingTimeChart', {
                title: 'Parse Time by Chain Length',
                xTitle: 'Repeat Units',
                yTitle: 'Time (log scale)',
                logScale: true,
                data: {
                    labels: allSizes.map(function (s) { return s.toLocaleString(); }),
                    datasets: [
                        { label: 'PEG (linear)',
                          data: allSizes.map(function (s) { return g.scaling.peg[s] || null; }),
                          backgroundColor: COLORS.orangeBg, borderColor: COLORS.orange, borderWidth: 1 },
                        { label: 'Teflon (branched)',
                          data: allSizes.map(function (s) { return g.scaling.teflon[s] || null; }),
                          backgroundColor: COLORS.purpleBg, borderColor: COLORS.purple, borderWidth: 1 }
                    ]
                }
            });

            // Per-unit chart
            barChart('scalingPerUnitChart', {
                title: 'Time per Repeat Unit',
                xTitle: 'Repeat Units',
                yTitle: 'ns / repeat unit',
                logScale: false,
                yTick: function (v) { return v.toFixed(0) + ' ns'; },
                tooltipLabel: function (ctx) {
                    return ctx.dataset.label + ': ' + ctx.raw.toFixed(1) + ' ns/unit';
                },
                data: {
                    labels: allSizes.map(function (s) { return s.toLocaleString(); }),
                    datasets: [
                        { label: 'PEG (linear)',
                          data: allSizes.map(function (s) {
                              var v = g.scaling.peg[s]; return v != null ? v / s : null;
                          }),
                          backgroundColor: COLORS.orangeBg, borderColor: COLORS.orange, borderWidth: 1 },
                        { label: 'Teflon (branched)',
                          data: allSizes.map(function (s) {
                              var v = g.scaling.teflon[s]; return v != null ? v / s : null;
                          }),
                          backgroundColor: COLORS.purpleBg, borderColor: COLORS.purple, borderWidth: 1 }
                    ]
                }
            });

            // Table
            var html = '<thead><tr>' +
                '<th>Chain Type</th><th>Repeat Units</th>' +
                '<th>Parse Time</th><th>ns / unit</th>' +
                '</tr></thead><tbody>';

            pegSizes.forEach(function (s) {
                var v = g.scaling.peg[s];
                html += '<tr><td>PEG (linear)</td><td>' + s.toLocaleString() +
                    '</td><td>' + formatNs(v) + '</td><td>' +
                    (v / s).toFixed(1) + ' ns</td></tr>';
            });
            teflonSizes.forEach(function (s) {
                var v = g.scaling.teflon[s];
                html += '<tr><td>Teflon (branched)</td><td>' + s.toLocaleString() +
                    '</td><td>' + formatNs(v) + '</td><td>' +
                    (v / s).toFixed(1) + ' ns</td></tr>';
            });

            html += '</tbody>';
            document.getElementById('scalingTable').innerHTML = html;
        }

        function buildReference(g) {
            var molecules = Object.keys(g.reference);
            if (!molecules.length) {
                document.getElementById('section-reference').style.display = 'none';
                return;
            }

            molecules.sort(function (a, b) { return g.reference[a] - g.reference[b]; });
            var values = molecules.map(function (m) { return g.reference[m]; });

            // Table
            var baseline = values[0];
            var html = '<thead><tr>' +
                '<th>Molecule</th><th>Parse Time</th><th>vs Simplest</th>' +
                '</tr></thead><tbody>';

            molecules.forEach(function (mol, i) {
                var ratio = values[i] / baseline;
                html += '<tr><td>' + mol + '</td><td>' + formatNs(values[i]) +
                    '</td><td>' + ratio.toFixed(1) + 'x</td></tr>';
            });

            html += '</tbody>';
            document.getElementById('referenceTable').innerHTML = html;
        }

        // ── Main ─────────────────────────────────────────────────

        function main() {
            var latest = getLatestBenches();

            if (!latest || !latest.benches || !latest.benches.length) {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').style.display   = 'block';
                return;
            }

            var groups = groupBenches(latest.benches);

            document.getElementById('loading').style.display = 'none';
            document.getElementById('content').style.display = 'block';

            buildSeqParallel(groups);
            buildScaling(groups);
            buildReference(groups);

            // Footer
            var date = new Date(latest.date * 1000);
            var sha  = (latest.commit && latest.commit.id)
                ? latest.commit.id.substring(0, 7) : '?';
            document.getElementById('lastUpdated').textContent =
                'Last updated: ' + date.toLocaleDateString('en-US', {
                    year: 'numeric', month: 'long', day: 'numeric'
                }) + ' (commit ' + sha + ')';
        }

        if (window.BENCHMARK_DATA) {
            main();
        } else {
            window.addEventListener('load', function () {
                if (window.BENCHMARK_DATA) { main(); }
                else {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('error').style.display   = 'block';
                }
            });
        }
    })();
    </script>
</body>
</html>
